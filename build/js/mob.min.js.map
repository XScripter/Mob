{"version":3,"sources":["Mob.js","module.js","lang.js","logger.js","mob.js","Mob.suffix"],"names":["factory","root","self","global","define","amd","$","Mob","jQuery","Zepto","ender","moduleBuild","module","SEPERATOR","localRequire","id","resultantId","charAt","slice","lastIndexOf","require","exports","previousMob","VERSION","noConflict","this","modules","requireStack","inProgressModules","cycle","join","length","push","pop","Module","remove","map","requireModule","defineModule","lang","ArrayProto","Array","prototype","ObjProto","Object","FuncProto","Function","toString","hasOwnProperty","nativeIsArray","isArray","nativeKeys","keys","nativeBind","bind","nativeCreate","create","Ctor","optimizeCb","func","context","argCount","value","call","other","index","collection","accumulator","apply","arguments","createAssigner","keysFunc","undefinedOnly","obj","source","l","i","key","baseCreate","isObject","result","property","MAX_ARRAY_INDEX","Math","pow","getLength","isArrayLike","each","iteratee","objectKeys","has","allKeys","extend","assign","defaults","type","name","Int8Array","isFunction","isNaN","isNumber","isBoolean","isNull","isUndefined","isEmpty","isString","isArguments","executeBound","sourceFunc","boundFunc","callingContext","args","TypeError","bound","concat","defaultMessageFormatter","messages","unshift","logHandler","Logger","contextualLoggersByNameMap","defineLogLevel","DEBUG","INFO","TIME","WARN","ERROR","OFF","ContextualLogger","defaultContext","setLevel","filterLevel","log","info","newLevel","enabledFor","lvl","debug","invoke","warn","error","time","label","timeEnd","level","msgArgs","globalLogger","method","setHandler","get","useDefaults","options","formatter","console","timerStartTimeByLabelMap","invokeConsoleMethod","hdlr","defaultLevel","timerLabel","Date","getTime"],"mappings":"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","file":"mob.min.js","sourcesContent":["  var previousMob = root.Mob;\n  \n  var Mob = {};\n  \n  Mob.$ = $;\n  \n  Mob.VERSION = '0.2.0';\n  \n  Mob.noConflict = function() {\n    root.Mob = previousMob;\n    return this;\n  };\n","  var require,\n    define,\n    modules = {},\n    requireStack = [],\n    inProgressModules = {};\n  \n  function moduleBuild(module) {\n    var factory = module.factory,\n      SEPERATOR = '.',\n      localRequire = function(id) {\n        var resultantId = id;\n        //Its a relative path, so lop off the last portion and add the id (minus './')\n        if (id.charAt(0) === SEPERATOR) {\n          resultantId = module.id.slice(0, module.id.lastIndexOf(SEPERATOR)) + SEPERATOR + id.slice(2);\n        }\n        return require(resultantId);\n      };\n  \n    module.exports = {};\n    delete module.factory;\n    factory(localRequire, module.exports, module);\n    return module.exports;\n  }\n  \n  require = function(id) {\n    if (!modules[id]) {\n      throw 'module ' + id + ' not found';\n    } else if (id in inProgressModules) {\n      var cycle = requireStack.slice(inProgressModules[id]).join('->') + '->' + id;\n      throw 'Cycle in module require graph: ' + cycle;\n    }\n    if (modules[id].factory) {\n      try {\n        inProgressModules[id] = requireStack.length;\n        requireStack.push(id);\n        return moduleBuild(modules[id]);\n      } finally {\n        delete inProgressModules[id];\n        requireStack.pop();\n      }\n    }\n    return modules[id].exports;\n  };\n  \n  define = function(id, factory) {\n    if (modules[id]) {\n      throw 'module ' + id + ' already defined';\n    }\n  \n    modules[id] = {\n      id: id,\n      factory: factory\n    };\n  };\n  \n  Mob.Module = {\n    require: require,\n    define: define,\n    remove: function(id) {\n      delete modules[id];\n    },\n    map: function() {\n      return modules;\n    }\n  };\n  Mob.requireModule = require;\n  Mob.defineModule = define;\n","  define('mob/lang', function(require, exports, module) {\n  \n    var lang = {};\n  \n    // Save bytes in the minified (but not gzipped) version:\n    var ArrayProto = Array.prototype,\n      ObjProto = Object.prototype,\n      FuncProto = Function.prototype;\n  \n    // Create quick reference variables for speed access to core prototypes.\n    var\n      push = ArrayProto.push,\n      slice = ArrayProto.slice,\n      toString = ObjProto.toString,\n      hasOwnProperty = ObjProto.hasOwnProperty;\n  \n    // All **ECMAScript 5** native function implementations that we hope to use\n    // are declared here.\n    var\n      nativeIsArray = Array.isArray,\n      nativeKeys = Object.keys,\n      nativeBind = FuncProto.bind,\n      nativeCreate = Object.create;\n  \n    // Naked function reference for surrogate-prototype-swapping.\n    var Ctor = function(){};\n  \n    var optimizeCb = function(func, context, argCount) {\n      if (context === void 0) {\n        return func;\n      }\n      switch (argCount == null ? 3 : argCount) {\n        case 1:\n          return function(value) {\n            return func.call(context, value);\n          };\n        case 2:\n          return function(value, other) {\n            return func.call(context, value, other);\n          };\n        case 3:\n          return function(value, index, collection) {\n            return func.call(context, value, index, collection);\n          };\n        case 4:\n          return function(accumulator, value, index, collection) {\n            return func.call(context, accumulator, value, index, collection);\n          };\n      }\n      return function() {\n        return func.apply(context, arguments);\n      };\n    };\n  \n    var createAssigner = function(keysFunc, undefinedOnly) {\n      return function(obj) {\n        var length = arguments.length;\n        if (length < 2 || obj == null) return obj;\n        for (var index = 1; index < length; index++) {\n          var source = arguments[index],\n            keys = keysFunc(source),\n            l = keys.length;\n          for (var i = 0; i < l; i++) {\n            var key = keys[i];\n            if (!undefinedOnly || obj[key] === void 0) {\n              obj[key] = source[key];\n            }\n          }\n        }\n        return obj;\n      };\n    };\n  \n    var baseCreate = function(prototype) {\n      if (!isObject(prototype)) {\n        return {};\n      }\n      if (nativeCreate) {\n        return nativeCreate(prototype);\n      }\n      Ctor.prototype = prototype;\n      var result = new Ctor;\n      Ctor.prototype = null;\n      return result;\n    };\n  \n    var property = function(key) {\n      return function(obj) {\n        return obj == null ? void 0 : obj[key];\n      };\n    };\n  \n    var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n    var getLength = property('length');\n    var isArrayLike = function(collection) {\n      var length = getLength(collection);\n      return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;\n    };\n  \n    // 集合(数组或对象)相关方法\n    // ==========================================================================================\n  \n    var each = lang.each = function(obj, iteratee, context) {\n      iteratee = optimizeCb(iteratee, context);\n      var i, length;\n      if (isArrayLike(obj)) {\n        for (i = 0, length = obj.length; i < length; i++) {\n          iteratee(obj[i], i, obj);\n        }\n      } else {\n        var keys = objectKeys(obj);\n        for (i = 0, length = keys.length; i < length; i++) {\n          iteratee(obj[keys[i]], keys[i], obj);\n        }\n      }\n      return obj;\n    };\n  \n    // 数组相关方法\n    // ==========================================================================================\n  \n  \n  \n    // 对象相关方法\n    // ==========================================================================================\n  \n    var objectKeys = lang.keys = function(obj) {\n      if (!isObject(obj)) {\n        return [];\n      }\n      if (nativeKeys) {\n        return nativeKeys(obj);\n      }\n      var keys = [];\n      for (var key in obj) {\n        if (has(obj, key)) {\n          keys.push(key);\n        }\n      }\n  \n      return keys;\n    };\n  \n    var allKeys = lang.allKeys = function(obj) {\n      if (!isObject(obj)) {\n        return [];\n      }\n      var keys = [];\n      for (var key in obj) {\n        keys.push(key);\n      }\n      return keys;\n    };\n  \n    lang.extend = createAssigner(allKeys);\n    lang.assign = createAssigner(objectKeys);\n    lang.defaults = createAssigner(allKeys, true);\n  \n    var isArray = lang.isArray = nativeIsArray || function(obj) {\n        return toString.call(obj) === '[object Array]';\n      };\n  \n  \n    var isObject = lang.isObject = function(obj) {\n      var type = typeof obj;\n      return type === 'function' || type === 'object' && !!obj;\n    };\n  \n    each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {\n      lang['is' + name] = function(obj) {\n        return toString.call(obj) === '[object ' + name + ']';\n      };\n    });\n  \n    // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,\n    // IE 11 (#1621), and in Safari 8 (#1929).\n    if (typeof /./ != 'function' && typeof Int8Array != 'object') {\n      lang.isFunction = function(obj) {\n        return typeof obj == 'function' || false;\n      };\n    }\n  \n    lang.isNaN = function(obj) {\n      return lang.isNumber(obj) && obj !== +obj;\n    };\n  \n    lang.isBoolean = function(obj) {\n      return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n    };\n  \n    lang.isNull = function(obj) {\n      return obj === null;\n    };\n  \n    lang.isUndefined = function(obj) {\n      return obj === void 0;\n    };\n  \n    lang.isEmpty = function(obj) {\n      if (obj == null) {\n        return true;\n      }\n      if (isArrayLike(obj) && (isArray(obj) || lang.isString(obj) || lang.isArguments(obj))) {\n        return obj.length === 0;\n      }\n      return objectKeys(obj).length === 0;\n    };\n  \n    var has = lang.has = function(obj, key) {\n      return obj != null && hasOwnProperty.call(obj, key);\n    };\n  \n    // 函数相关方法\n    // ==========================================================================================\n    var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {\n      if (!(callingContext instanceof boundFunc)) {\n        return sourceFunc.apply(context, args);\n      }\n      var self = baseCreate(sourceFunc.prototype);\n      var result = sourceFunc.apply(self, args);\n      if (isObject(result)) {\n        return result;\n      }\n      return self;\n    };\n  \n    lang.bind = function(func, context) {\n      if (nativeBind && func.bind === nativeBind) {\n        return nativeBind.apply(func, slice.call(arguments, 1));\n      }\n      if (!lang.isFunction(func)) {\n        throw new TypeError('Bind must be called on a function');\n      }\n      var args = slice.call(arguments, 2);\n      var bound = function() {\n        return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));\n      };\n      return bound;\n    };\n  \n    module.exports = lang;\n  \n  });\n  var lang = require('mob/lang');\n  lang.extend(Mob, lang);\n","  define('mob/logger', function(require, exports, module) {\n  \n    var lang = require('mob/lang');\n  \n    var Logger = {};\n  \n    var logHandler;\n    var contextualLoggersByNameMap = {};\n  \n    function defaultMessageFormatter(messages, context) {\n      if (context.name) {\n        messages.unshift('[' + context.name + ']');\n      }\n    }\n  \n    var defineLogLevel = function(value, name) {\n      return {\n        value: value,\n        name: name\n      };\n    };\n  \n    Logger.DEBUG = defineLogLevel(1, 'DEBUG');\n    Logger.INFO = defineLogLevel(2, 'INFO');\n    Logger.TIME = defineLogLevel(3, 'TIME');\n    Logger.WARN = defineLogLevel(4, 'WARN');\n    Logger.ERROR = defineLogLevel(8, 'ERROR');\n    Logger.OFF = defineLogLevel(99, 'OFF');\n  \n    var ContextualLogger = function(defaultContext) {\n      this.context = defaultContext;\n      this.setLevel(defaultContext.filterLevel);\n      this.log = this.info;\n    };\n  \n    ContextualLogger.prototype = {\n  \n      setLevel: function(newLevel) {\n        if (newLevel && 'value' in newLevel) {\n          this.context.filterLevel = newLevel;\n        }\n      },\n  \n      enabledFor: function(lvl) {\n        var filterLevel = this.context.filterLevel;\n        return lvl.value >= filterLevel.value;\n      },\n  \n      debug: function() {\n        this.invoke(Logger.DEBUG, arguments);\n      },\n  \n      info: function() {\n        this.invoke(Logger.INFO, arguments);\n      },\n  \n      warn: function() {\n        this.invoke(Logger.WARN, arguments);\n      },\n  \n      error: function() {\n        this.invoke(Logger.ERROR, arguments);\n      },\n  \n      time: function(label) {\n        if (typeof label === 'string' && label.length > 0) {\n          this.invoke(Logger.TIME, [label, 'start']);\n        }\n      },\n  \n      timeEnd: function(label) {\n        if (typeof label === 'string' && label.length > 0) {\n          this.invoke(Logger.TIME, [label, 'end']);\n        }\n      },\n  \n      invoke: function(level, msgArgs) {\n        if (logHandler && this.enabledFor(level)) {\n          logHandler(msgArgs, lang.extend({\n            level: level\n          }, this.context));\n        }\n      }\n    };\n  \n    var globalLogger = new ContextualLogger({\n      filterLevel: Logger.OFF\n    });\n  \n    lang.each(['enabledFor', 'debug', 'time', 'timeEnd', 'info', 'warn', 'error'], function(method) {\n      Logger[method] = lang.bind(globalLogger[method], globalLogger);\n    });\n  \n    Logger.log = Logger.info;\n  \n    Logger.setHandler = function(func) {\n      logHandler = func;\n    };\n  \n    Logger.setLevel = function(level) {\n      globalLogger.setLevel(level);\n  \n      for (var key in contextualLoggersByNameMap) {\n        if (contextualLoggersByNameMap.hasOwnProperty(key)) {\n          contextualLoggersByNameMap[key].setLevel(level);\n        }\n      }\n    };\n  \n    Logger.get = function(name) {\n      return contextualLoggersByNameMap[name] ||\n        (contextualLoggersByNameMap[name] = new ContextualLogger(lang.extend({\n          name: name\n        }, globalLogger.context)));\n    };\n  \n    Logger.useDefaults = function(options) {\n      options = options || {};\n  \n      options.formatter = options.formatter || defaultMessageFormatter;\n  \n      if (typeof console === 'undefined') {\n        return;\n      }\n  \n      var timerStartTimeByLabelMap = {};\n  \n      var invokeConsoleMethod = function(hdlr, messages) {\n        Function.prototype.apply.call(hdlr, console, messages);\n      };\n  \n      Logger.setLevel(options.defaultLevel || Logger.DEBUG);\n      Logger.setHandler(function(messages, context) {\n        messages = Array.prototype.slice.call(messages);\n  \n        var hdlr = console.log;\n        var timerLabel;\n  \n        if (context.level === Logger.TIME) {\n          timerLabel = (context.name ? '[' + context.name + '] ' : '') + messages[0];\n  \n          if (messages[1] === 'start') {\n            if (console.time) {\n              console.time(timerLabel);\n            } else {\n              timerStartTimeByLabelMap[timerLabel] = new Date().getTime();\n            }\n          } else {\n            if (console.timeEnd) {\n              console.timeEnd(timerLabel);\n            } else {\n              invokeConsoleMethod(hdlr, [timerLabel + ': ' + (new Date().getTime() - timerStartTimeByLabelMap[timerLabel]) + 'ms']);\n            }\n          }\n        } else {\n          if (context.level === Logger.WARN && console.warn) {\n            hdlr = console.warn;\n          } else if (context.level === Logger.ERROR && console.error) {\n            hdlr = console.error;\n          } else if (context.level === Logger.INFO && console.info) {\n            hdlr = console.info;\n          }\n  \n          options.formatter(messages, context);\n          invokeConsoleMethod(hdlr, messages);\n        }\n      });\n    };\n  \n    module.exports = Logger;\n  \n  });\n  Mob.Logger = require('mob/logger');\n  Mob.each(['debug', 'time', 'timeEnd', 'info', 'warn', 'error', 'log'], function(method) {\n    Mob[method] = Mob.Logger[method];\n  });\n","/**\n * Mobird 0.2.0\n * Full Featured HTML5 Framework For Building Mobile Apps\n * \n * http://www.xscripter.com/mobird/\n * \n * Copyright 2015, Clarence Hu\n * The XScripter.com\n * http://www.xscripter.com/\n * \n * Licensed under MIT\n * \n * Released on: October 14, 2015\n */\n(function(factory) {\n  var root = (typeof self == 'object' && self.self == self && self) ||\n      (typeof global == 'object' && global.global == global && global);\n  if (typeof define === 'function' && define.amd) {\n    define(['jquery'], function($) {\n      root.Mob = factory(root, $);\n    });\n  } else {\n    root.Mob = factory(root, (root.jQuery || root.Zepto || root.ender || root.$));\n  }\n}(function(root, $) {\n\n  var previousMob = root.Mob;\n  \n  var Mob = {};\n  \n  Mob.$ = $;\n  \n  Mob.VERSION = '0.2.0';\n  \n  Mob.noConflict = function() {\n    root.Mob = previousMob;\n    return this;\n  };\n\n  var require,\n    define,\n    modules = {},\n    requireStack = [],\n    inProgressModules = {};\n  \n  function moduleBuild(module) {\n    var factory = module.factory,\n      SEPERATOR = '.',\n      localRequire = function(id) {\n        var resultantId = id;\n        //Its a relative path, so lop off the last portion and add the id (minus './')\n        if (id.charAt(0) === SEPERATOR) {\n          resultantId = module.id.slice(0, module.id.lastIndexOf(SEPERATOR)) + SEPERATOR + id.slice(2);\n        }\n        return require(resultantId);\n      };\n  \n    module.exports = {};\n    delete module.factory;\n    factory(localRequire, module.exports, module);\n    return module.exports;\n  }\n  \n  require = function(id) {\n    if (!modules[id]) {\n      throw 'module ' + id + ' not found';\n    } else if (id in inProgressModules) {\n      var cycle = requireStack.slice(inProgressModules[id]).join('->') + '->' + id;\n      throw 'Cycle in module require graph: ' + cycle;\n    }\n    if (modules[id].factory) {\n      try {\n        inProgressModules[id] = requireStack.length;\n        requireStack.push(id);\n        return moduleBuild(modules[id]);\n      } finally {\n        delete inProgressModules[id];\n        requireStack.pop();\n      }\n    }\n    return modules[id].exports;\n  };\n  \n  define = function(id, factory) {\n    if (modules[id]) {\n      throw 'module ' + id + ' already defined';\n    }\n  \n    modules[id] = {\n      id: id,\n      factory: factory\n    };\n  };\n  \n  Mob.Module = {\n    require: require,\n    define: define,\n    remove: function(id) {\n      delete modules[id];\n    },\n    map: function() {\n      return modules;\n    }\n  };\n  Mob.requireModule = require;\n  Mob.defineModule = define;\n\n  define('mob/lang', function(require, exports, module) {\n  \n    var lang = {};\n  \n    // Save bytes in the minified (but not gzipped) version:\n    var ArrayProto = Array.prototype,\n      ObjProto = Object.prototype,\n      FuncProto = Function.prototype;\n  \n    // Create quick reference variables for speed access to core prototypes.\n    var\n      push = ArrayProto.push,\n      slice = ArrayProto.slice,\n      toString = ObjProto.toString,\n      hasOwnProperty = ObjProto.hasOwnProperty;\n  \n    // All **ECMAScript 5** native function implementations that we hope to use\n    // are declared here.\n    var\n      nativeIsArray = Array.isArray,\n      nativeKeys = Object.keys,\n      nativeBind = FuncProto.bind,\n      nativeCreate = Object.create;\n  \n    // Naked function reference for surrogate-prototype-swapping.\n    var Ctor = function(){};\n  \n    var optimizeCb = function(func, context, argCount) {\n      if (context === void 0) {\n        return func;\n      }\n      switch (argCount == null ? 3 : argCount) {\n        case 1:\n          return function(value) {\n            return func.call(context, value);\n          };\n        case 2:\n          return function(value, other) {\n            return func.call(context, value, other);\n          };\n        case 3:\n          return function(value, index, collection) {\n            return func.call(context, value, index, collection);\n          };\n        case 4:\n          return function(accumulator, value, index, collection) {\n            return func.call(context, accumulator, value, index, collection);\n          };\n      }\n      return function() {\n        return func.apply(context, arguments);\n      };\n    };\n  \n    var createAssigner = function(keysFunc, undefinedOnly) {\n      return function(obj) {\n        var length = arguments.length;\n        if (length < 2 || obj == null) return obj;\n        for (var index = 1; index < length; index++) {\n          var source = arguments[index],\n            keys = keysFunc(source),\n            l = keys.length;\n          for (var i = 0; i < l; i++) {\n            var key = keys[i];\n            if (!undefinedOnly || obj[key] === void 0) {\n              obj[key] = source[key];\n            }\n          }\n        }\n        return obj;\n      };\n    };\n  \n    var baseCreate = function(prototype) {\n      if (!isObject(prototype)) {\n        return {};\n      }\n      if (nativeCreate) {\n        return nativeCreate(prototype);\n      }\n      Ctor.prototype = prototype;\n      var result = new Ctor;\n      Ctor.prototype = null;\n      return result;\n    };\n  \n    var property = function(key) {\n      return function(obj) {\n        return obj == null ? void 0 : obj[key];\n      };\n    };\n  \n    var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;\n    var getLength = property('length');\n    var isArrayLike = function(collection) {\n      var length = getLength(collection);\n      return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;\n    };\n  \n    // 集合(数组或对象)相关方法\n    // ==========================================================================================\n  \n    var each = lang.each = function(obj, iteratee, context) {\n      iteratee = optimizeCb(iteratee, context);\n      var i, length;\n      if (isArrayLike(obj)) {\n        for (i = 0, length = obj.length; i < length; i++) {\n          iteratee(obj[i], i, obj);\n        }\n      } else {\n        var keys = objectKeys(obj);\n        for (i = 0, length = keys.length; i < length; i++) {\n          iteratee(obj[keys[i]], keys[i], obj);\n        }\n      }\n      return obj;\n    };\n  \n    // 数组相关方法\n    // ==========================================================================================\n  \n  \n  \n    // 对象相关方法\n    // ==========================================================================================\n  \n    var objectKeys = lang.keys = function(obj) {\n      if (!isObject(obj)) {\n        return [];\n      }\n      if (nativeKeys) {\n        return nativeKeys(obj);\n      }\n      var keys = [];\n      for (var key in obj) {\n        if (has(obj, key)) {\n          keys.push(key);\n        }\n      }\n  \n      return keys;\n    };\n  \n    var allKeys = lang.allKeys = function(obj) {\n      if (!isObject(obj)) {\n        return [];\n      }\n      var keys = [];\n      for (var key in obj) {\n        keys.push(key);\n      }\n      return keys;\n    };\n  \n    lang.extend = createAssigner(allKeys);\n    lang.assign = createAssigner(objectKeys);\n    lang.defaults = createAssigner(allKeys, true);\n  \n    var isArray = lang.isArray = nativeIsArray || function(obj) {\n        return toString.call(obj) === '[object Array]';\n      };\n  \n  \n    var isObject = lang.isObject = function(obj) {\n      var type = typeof obj;\n      return type === 'function' || type === 'object' && !!obj;\n    };\n  \n    each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {\n      lang['is' + name] = function(obj) {\n        return toString.call(obj) === '[object ' + name + ']';\n      };\n    });\n  \n    // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,\n    // IE 11 (#1621), and in Safari 8 (#1929).\n    if (typeof /./ != 'function' && typeof Int8Array != 'object') {\n      lang.isFunction = function(obj) {\n        return typeof obj == 'function' || false;\n      };\n    }\n  \n    lang.isNaN = function(obj) {\n      return lang.isNumber(obj) && obj !== +obj;\n    };\n  \n    lang.isBoolean = function(obj) {\n      return obj === true || obj === false || toString.call(obj) === '[object Boolean]';\n    };\n  \n    lang.isNull = function(obj) {\n      return obj === null;\n    };\n  \n    lang.isUndefined = function(obj) {\n      return obj === void 0;\n    };\n  \n    lang.isEmpty = function(obj) {\n      if (obj == null) {\n        return true;\n      }\n      if (isArrayLike(obj) && (isArray(obj) || lang.isString(obj) || lang.isArguments(obj))) {\n        return obj.length === 0;\n      }\n      return objectKeys(obj).length === 0;\n    };\n  \n    var has = lang.has = function(obj, key) {\n      return obj != null && hasOwnProperty.call(obj, key);\n    };\n  \n    // 函数相关方法\n    // ==========================================================================================\n    var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {\n      if (!(callingContext instanceof boundFunc)) {\n        return sourceFunc.apply(context, args);\n      }\n      var self = baseCreate(sourceFunc.prototype);\n      var result = sourceFunc.apply(self, args);\n      if (isObject(result)) {\n        return result;\n      }\n      return self;\n    };\n  \n    lang.bind = function(func, context) {\n      if (nativeBind && func.bind === nativeBind) {\n        return nativeBind.apply(func, slice.call(arguments, 1));\n      }\n      if (!lang.isFunction(func)) {\n        throw new TypeError('Bind must be called on a function');\n      }\n      var args = slice.call(arguments, 2);\n      var bound = function() {\n        return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));\n      };\n      return bound;\n    };\n  \n    module.exports = lang;\n  \n  });\n  var lang = require('mob/lang');\n  lang.extend(Mob, lang);\n\n  define('mob/logger', function(require, exports, module) {\n  \n    var lang = require('mob/lang');\n  \n    var Logger = {};\n  \n    var logHandler;\n    var contextualLoggersByNameMap = {};\n  \n    function defaultMessageFormatter(messages, context) {\n      if (context.name) {\n        messages.unshift('[' + context.name + ']');\n      }\n    }\n  \n    var defineLogLevel = function(value, name) {\n      return {\n        value: value,\n        name: name\n      };\n    };\n  \n    Logger.DEBUG = defineLogLevel(1, 'DEBUG');\n    Logger.INFO = defineLogLevel(2, 'INFO');\n    Logger.TIME = defineLogLevel(3, 'TIME');\n    Logger.WARN = defineLogLevel(4, 'WARN');\n    Logger.ERROR = defineLogLevel(8, 'ERROR');\n    Logger.OFF = defineLogLevel(99, 'OFF');\n  \n    var ContextualLogger = function(defaultContext) {\n      this.context = defaultContext;\n      this.setLevel(defaultContext.filterLevel);\n      this.log = this.info;\n    };\n  \n    ContextualLogger.prototype = {\n  \n      setLevel: function(newLevel) {\n        if (newLevel && 'value' in newLevel) {\n          this.context.filterLevel = newLevel;\n        }\n      },\n  \n      enabledFor: function(lvl) {\n        var filterLevel = this.context.filterLevel;\n        return lvl.value >= filterLevel.value;\n      },\n  \n      debug: function() {\n        this.invoke(Logger.DEBUG, arguments);\n      },\n  \n      info: function() {\n        this.invoke(Logger.INFO, arguments);\n      },\n  \n      warn: function() {\n        this.invoke(Logger.WARN, arguments);\n      },\n  \n      error: function() {\n        this.invoke(Logger.ERROR, arguments);\n      },\n  \n      time: function(label) {\n        if (typeof label === 'string' && label.length > 0) {\n          this.invoke(Logger.TIME, [label, 'start']);\n        }\n      },\n  \n      timeEnd: function(label) {\n        if (typeof label === 'string' && label.length > 0) {\n          this.invoke(Logger.TIME, [label, 'end']);\n        }\n      },\n  \n      invoke: function(level, msgArgs) {\n        if (logHandler && this.enabledFor(level)) {\n          logHandler(msgArgs, lang.extend({\n            level: level\n          }, this.context));\n        }\n      }\n    };\n  \n    var globalLogger = new ContextualLogger({\n      filterLevel: Logger.OFF\n    });\n  \n    lang.each(['enabledFor', 'debug', 'time', 'timeEnd', 'info', 'warn', 'error'], function(method) {\n      Logger[method] = lang.bind(globalLogger[method], globalLogger);\n    });\n  \n    Logger.log = Logger.info;\n  \n    Logger.setHandler = function(func) {\n      logHandler = func;\n    };\n  \n    Logger.setLevel = function(level) {\n      globalLogger.setLevel(level);\n  \n      for (var key in contextualLoggersByNameMap) {\n        if (contextualLoggersByNameMap.hasOwnProperty(key)) {\n          contextualLoggersByNameMap[key].setLevel(level);\n        }\n      }\n    };\n  \n    Logger.get = function(name) {\n      return contextualLoggersByNameMap[name] ||\n        (contextualLoggersByNameMap[name] = new ContextualLogger(lang.extend({\n          name: name\n        }, globalLogger.context)));\n    };\n  \n    Logger.useDefaults = function(options) {\n      options = options || {};\n  \n      options.formatter = options.formatter || defaultMessageFormatter;\n  \n      if (typeof console === 'undefined') {\n        return;\n      }\n  \n      var timerStartTimeByLabelMap = {};\n  \n      var invokeConsoleMethod = function(hdlr, messages) {\n        Function.prototype.apply.call(hdlr, console, messages);\n      };\n  \n      Logger.setLevel(options.defaultLevel || Logger.DEBUG);\n      Logger.setHandler(function(messages, context) {\n        messages = Array.prototype.slice.call(messages);\n  \n        var hdlr = console.log;\n        var timerLabel;\n  \n        if (context.level === Logger.TIME) {\n          timerLabel = (context.name ? '[' + context.name + '] ' : '') + messages[0];\n  \n          if (messages[1] === 'start') {\n            if (console.time) {\n              console.time(timerLabel);\n            } else {\n              timerStartTimeByLabelMap[timerLabel] = new Date().getTime();\n            }\n          } else {\n            if (console.timeEnd) {\n              console.timeEnd(timerLabel);\n            } else {\n              invokeConsoleMethod(hdlr, [timerLabel + ': ' + (new Date().getTime() - timerStartTimeByLabelMap[timerLabel]) + 'ms']);\n            }\n          }\n        } else {\n          if (context.level === Logger.WARN && console.warn) {\n            hdlr = console.warn;\n          } else if (context.level === Logger.ERROR && console.error) {\n            hdlr = console.error;\n          } else if (context.level === Logger.INFO && console.info) {\n            hdlr = console.info;\n          }\n  \n          options.formatter(messages, context);\n          invokeConsoleMethod(hdlr, messages);\n        }\n      });\n    };\n  \n    module.exports = Logger;\n  \n  });\n  Mob.Logger = require('mob/logger');\n  Mob.each(['debug', 'time', 'timeEnd', 'info', 'warn', 'error', 'log'], function(method) {\n    Mob[method] = Mob.Logger[method];\n  });\n\n  return Mob;\n\n}));","  return Mob;\n\n}));"],"sourceRoot":"/source/"}